local ctr = require "main.controller"

local  particlecount = 500

local lWall = hash("/lWall")
local rWall = hash("/rWall")
local tWall = hash("/tWall")
local bWall = hash("/bWall")
local ball = hash("/ball")

local vdown = vmath.vector3(0, -1, 0)
local vleft = vmath.vector3(-1, 0, 0)
local vright = vmath.vector3(1, 0, 0)
local vup = vmath.vector3(0, 1, 0)
local _normal = vdown
local currentBall

local normal_velocity = vmath.vector3()
local tangent_velocity  = vmath.vector3()
local setposition = go.set_position
local _wallResult = {}
-- local ball1 = hash("/ball1")

local ballSpeed = 600


local prt = {
  {
    sprite= hash("20x20_circle"),
    type = 0,
    size = vmath.vector3(20,20,0)
  },
  {
    sprite= hash("30x30_circle"),
    type = 0,
    size =vmath.vector3(30,30,0)
  }
}


local balls={}


local function insetParticles ()
  local _particleId

  local pos = vmath.vector3()
  pos = vmath.vector3( math.random (100, 1000),  math.random (100, 600), 0)
  local _targetId =  factory.create("/factory#particle",pos)
  local _sprite = msg.url("default", _targetId, "sprite")
  local rnd =math.random (1,2)
  local rndSprite = prt[rnd]["sprite"]
  local spriteSize = prt[rnd]["size"]
  msg.post(_sprite, "play_animation", {id = rndSprite})

  local ballVelocity = vmath.vector3()
  ballVelocity.x = (math.random(5, 10) / 10) * ballSpeed
  ballVelocity.y = (math.random(5, 10) / 10) * ballSpeed

  local _radius = spriteSize.x/2
  local _id = daabbcc.insertCircle("balls", _radius, pos.x , pos.y)
  table.insert(balls,#balls+1, {
    _id,
    _targetId,
    pos,
    _radius,
    ballVelocity
  }
)
end

function init(self)
  msg.post("@system:", "toggle_profile")
  math.randomseed(os.time())

  daabbcc.createTree("walls", 2, 0.0, 4)
  daabbcc.createTree("balls", 2, 0.1, particlecount)


  --lWall 0
  local _pos = go.get_position(lWall)
  local _sprite =  msg.url("default", lWall, "sprite")
  local _spriteSize = go.get(_sprite, "size")
  ctr.addRect("walls", _spriteSize, _pos, 0, 0, 0)

  --rWall 1
  _pos = go.get_position(rWall)
  _sprite =  msg.url("default", rWall, "sprite")
  _spriteSize = go.get(_sprite, "size")
  ctr.addRect("walls", _spriteSize, _pos, 0, 0, 0)

  --tWall 2
  _pos = go.get_position(tWall)
  _sprite =  msg.url("default", tWall, "sprite")
  _spriteSize = go.get(_sprite, "size")
  ctr.addRect("walls", _spriteSize, _pos, 0, 0, 0)

  --bWall 3
  _pos = go.get_position(bWall)
  _sprite =  msg.url("default", bWall, "sprite")
  _spriteSize = go.get(_sprite, "size")
  ctr.addRect("walls", _spriteSize, _pos, 0, 0, 0)

  math.randomseed(os.time())
  for i=1,particlecount do
    insetParticles()
  end
end


local function updateBalls(dt)
  for i=1,particlecount do   --loop all balls
    currentBall = balls[i]
    currentBall[3] = currentBall[3]+currentBall[5]*dt   -- Next Frame position

    --Check if there is a wall on next frame
    _wallResult = daabbcc.queryAABB("walls", currentBall[3].x,currentBall[3].y,currentBall[4]*2,currentBall[4]*2 )

    local _resultCount = #_wallResult
    if _resultCount > 0  then --Ball is going to hit on next Frame
      -- Walls: 0 LEFT, 1 RIGHT, 2 TOP, 3 BOTTOM
      _normal = vdown -- 2 Top
      if _wallResult[_resultCount] == 1 then -- 1 RIGHT
        _normal = vleft
      elseif _wallResult[_resultCount] == 0 then -- 1 LEFT
        _normal = vright
      elseif _wallResult[_resultCount] == 3 then -- 3 BOTTOM
        _normal = vup
      end
      --Calculate new position and velocity
      normal_velocity = vmath.dot(_normal, currentBall[5]) * _normal
      tangent_velocity = currentBall[5] - normal_velocity
      normal_velocity = normal_velocity * -1
      currentBall[5] = normal_velocity + tangent_velocity
      currentBall[3] = currentBall[3] + (_normal * 10.5)
    end -- wall result

  --  daabbcc.updateCircle("balls",currentBall[1], currentBall[4], currentBall[3].x , currentBall[3].y)

    -- Not possible to demo this with large quantity.
    --Check if there is a ball on next frame
    -- local _ballResult = daabbcc.queryID("balls", currentBall[1])
    -- local _ballCount = #_ballResult
    -- local angle = math.atan2(currentBall[5].y, currentBall[5].x)
    --
    -- if _ballCount > 0  then
    --   local _normal = vdown
    --   if angle > 0 and angle < 2 then --Top right
    --     _normal = vdown + vleft
    --   end
    --
    --   if angle > 2  then --Top left
    --     _normal = vdown + vright
    --   end
    --
    --   if angle < -2  then --Bottom left
    --     _normal = vup + vright
    --   end
    --
    --   if angle < -0 and angle > -2 then --Bottom right
    --     _normal = vup + vleft
    --   end
    --   normal_velocity = vmath.dot(_normal, currentBall[5]) * _normal
    --   tangent_velocity = currentBall[5] - normal_velocity
    --   normal_velocity = normal_velocity * -0
    --   currentBall[5] = normal_velocity + tangent_velocity
    --   currentBall[3] = currentBall[3] + (_normal * 20.2)
    -- end

    setposition(currentBall[3], currentBall[2])
    daabbcc.updateCircle("balls",currentBall[1], currentBall[4], currentBall[3].x , currentBall[3].y)

  end --end loop all balls
end


function update(self, dt)
  updateBalls(dt)
end
