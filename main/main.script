local ctr = require "main.controller"

local _id = 0
local _height = 0
local _nodeCount = 0
local viewport= hash("/viewport")
local  particlecount = 700

local v_x = 0
local v_y = 0
local v_w = 0
local v_h = 0

local bounds = vmath.vector3(960,640,0)
local prevResult={}
local _particleGroup = {}
local _particleM = {}
local _particlePosition = vmath.vector3()
local _queryResult = {}

local _queryCount = 0

local prt = {
  {
    sprite= hash("20x20_circle"),
    type = 0,
    size = vmath.vector3(20,20,0)
  },
  {
    sprite= hash("30x30_circle"),
    type = 0,
    size =vmath.vector3(30,30,0)
  },
  {
    sprite= hash("40x40_rect"),
    type = 1,
    size = vmath.vector3(40,40,0)
  },
  {
    sprite= hash("60x30_rect"),
    type = 1,
    size = vmath.vector3(60,30,0)
  }
}





local function insetParticles ()
  local _particleId
  local lr = math.random (0, 1)
  local pos = vmath.vector3()
  if lr == 0 then
pos = vmath.vector3( math.random (0, 0),  math.random (0, 600), 0)
else
  pos = vmath.vector3( math.random (900, 900),  math.random (0, 600), 0)
end

  local _targetId =  factory.create("/factory#particle",pos)
  local _sprite = msg.url("main", _targetId, "sprite")
  local _label = msg.url("main", _targetId, "label")
  local rnd =math.random (1,4)
  local rndSprite = prt[rnd]["sprite"]
  local rndType = prt[rnd]["type"]
  local spriteSize = prt[rnd]["size"]
  msg.post(_sprite, "play_animation", {id = rndSprite})

  if rndType == 0 then
    _particleId = ctr.addCircle("particles", spriteSize,pos, _targetId,_sprite,rndType)
  else
    _particleId =   ctr.addRect("particles", spriteSize, pos, _targetId,_sprite,rndType)
  end

  --label.set_text(_label, (_particleId .. " / " .. pos.x .. " - " .. pos.y) )
end

local function setNewAnimate(self, url, property)
  local _to = vmath.vector3()
  _to.x =  math.random (0, bounds.x)
  _to.y = math.random (0, bounds.y)
  _to.z = 0
  local ss = math.random (1.5, 4)
  go.animate(url, "position",  go.PLAYBACK_ONCE_FORWARD, _to, go.EASING_LINEAR, ss,0,setNewAnimate)

end
local function setAnimate()

  for i=1, #_particleGroup do
    local _to = vmath.vector3()
    _to.x =  math.random (0, bounds.x)
    _to.y = math.random (0, bounds.y)
    _to.z = 0
    local ss = math.random (2, 5)
    go.animate(_particleGroup[i][2], "position",  go.PLAYBACK_ONCE_FORWARD, _to, go.EASING_LINEAR, ss,0,setNewAnimate)
  end
end


function init(self)
 --msg.post("@system:", "toggle_profile")
  daabbcc.createTree("particles", 2, 0.2, particlecount)


  local viewport_sprite = msg.url("main", viewport, "sprite")
  local viewport_size = go.get(viewport_sprite, "size")
  local viewport_pos = go.get_position(viewport)


  math.randomseed(os.time())
  for i=1,particlecount do
    insetParticles()
  end
  _particleGroup = ctr.particleGroup

  --pprint(_particleGroup)

  print("-------------------")
  pprint("viewport_pos: ".. viewport_pos)
  pprint("viewport_size: ".. viewport_size)
  v_x = viewport_pos.x
  v_y = viewport_pos.y
  v_w = viewport_size.x
  v_h = viewport_size.y
  --[[
  xl = x-(w/2)
  yb = y-(h/2)
  xr = x+(w/2)
  yt = y+(h/2)

  print("xl: " , xl)
  print("yb: " , yb)
  print("xr: " , xr)
  print("yt: " , yt)
  ]]--

  --local _result = daabbcc.queryAABB("particles",v_x,v_y,v_w,v_h)
  --pprint(_result)
  --daabbcc.removeAABB("particles",0)

  --  table.remove(_particleGroup, 2)

  --  pprint(_particleGroup)
  setAnimate()
end

local function difference(a, b)
  local aa = {}
  for k,v in pairs(a) do aa[v]=true end
  for k,v in pairs(b) do aa[v]=nil end
  local ret = {}
  local n = 0
  for k,v in pairs(a) do
    if aa[v] then n=n+1 ret[n]=v end
  end
  return ret
end



local function checkCollision()

  _queryResult = daabbcc.queryAABB("particles",v_x,v_y,v_w,v_h)
  _queryCount = #_queryResult

  for i = 1, _queryCount do
    daabbcc.removeAABB("particles",_queryResult[i])

    for z=1,#_particleGroup do
      _particleM= _particleGroup[z]
      if _particleM[1] == _queryResult[i] then
        go.delete(_particleM[2],true)
        --go.cancel_animations(_particleM[2],"position")
        table.remove(_particleGroup, z)
        break
      end
    end


  end
  -- local tprevResult = difference(prevResult , _queryResult)
  -- if #tprevResult > 0 then
  --
  --   for i = 1, #tprevResult do
  --     local ll = ctr.particleGroup[tprevResult[i]]
  --
  --     if ll[7] == true then
  --       go.animate(ll[3], 'tint.w', go.PLAYBACK_ONCE_FORWARD, 1, go.EASING_LINEAR, 0.1)
  --       ll[7] = false
  --     end
  --   end
  -- end
  --
  --
  --
  -- for i = 1, #_queryResult do
  --   local ll = ctr.particleGroup[_queryResult[i]]
  --   if ll[7] == false then
  --     go.cancel_animations(ll[2],"position")
  --
  --     go.animate(ll[3], 'tint.w', go.PLAYBACK_ONCE_FORWARD, 0.5, go.EASING_LINEAR, 0.1)
  --     ll[7] = true
  --
  --     -- Remove from removeAABB
  --
  --    --[[
  --     pprint(ll[1])
  --     daabbcc.removeAABB("particles",ll[1] )
  --     table.remove(ctr.particleGroup,ll[1])
  --     table.remove(_result,_i)
  --   ]]--
  --   end
  -- end
  -- prevResult = _result
end

function update(self, dt)

  for i=1, #_particleGroup do
    _particleM = _particleGroup[i]
    _particlePosition = go.get_position(_particleM[2])
    if _particleM[5]== 0 then
      ctr.updateCircle("particles",_particleM[6], _particlePosition, _particleM[1])
    else
      ctr.updateRect("particles",_particleM[6], _particlePosition, _particleM[1])
    end
  end
  checkCollision()


end

function on_message(self, message_id, message, sender)
  -- Add message-handling code here
  -- Remove this function if not needed
end

function on_input(self, action_id, action)
  -- Add input-handling code here
  -- Remove this function if not needed
end

function on_reload(self)
  -- Add reload-handling code here
  -- Remove this function if not needed
end
